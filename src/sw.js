// Custom Service Worker for handling notifications
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst } from 'workbox-strategies';

// Precache all the assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST);

// Clean up outdated caches
cleanupOutdatedCaches();

// Cache strategies
registerRoute(
  ({ request }) => request.destination === 'document',
  new NetworkFirst()
);

registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst()
);

// Handle notification click events
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  const data = event.notification.data || {};
  
  // Handle different notification actions
  if (event.action === 'view' || event.action === 'answer' || !event.action) {
    let urlToOpen = '/dashboard';
    
    // Determine the URL based on notification data
    if (data.reportId) {
      if (event.action === 'answer' || data.action === 'questions_needed') {
        urlToOpen = `/report/${data.reportId}`;
      } else if (data.action === 'questions_completed') {
        urlToOpen = `/report/${data.reportId}`;
      } else {
        urlToOpen = `/report/${data.reportId}`;
      }
    } else if (data.url) {
      urlToOpen = data.url;
    }
    
    event.waitUntil(
      clients.matchAll({ type: 'window', includeUncontrolled: true })
        .then((clientList) => {
          // Check if there's already a window/tab open with the target URL
          for (const client of clientList) {
            if (client.url.includes(urlToOpen.split('?')[0]) && 'focus' in client) {
              return client.focus();
            }
          }
          
          // If no window/tab is open, open a new one
          if (clients.openWindow) {
            return clients.openWindow(urlToOpen);
          }
        })
    );
  }
});

// Handle notification close events
self.addEventListener('notificationclose', (event) => {
  console.log('Notification closed:', event.notification.tag);
});

// Background sync for offline complaint submission
self.addEventListener('sync', (event) => {
  if (event.tag === 'background-complaint-sync') {
    event.waitUntil(syncComplaints());
  }
});

async function syncComplaints() {
  try {
    // Get pending complaints from IndexedDB or localStorage
    const pendingComplaints = JSON.parse(localStorage.getItem('pendingComplaints') || '[]');
    
    for (const complaint of pendingComplaints) {
      try {
        const response = await fetch('http://localhost:3000/complaints', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(complaint)
        });
        
        if (response.ok) {
          // Remove from pending list
          const updatedPending = pendingComplaints.filter(c => c.tempId !== complaint.tempId);
          localStorage.setItem('pendingComplaints', JSON.stringify(updatedPending));
          
          // Show success notification
          self.registration.showNotification('Complaint Synced', {
            body: 'Your offline complaint has been submitted successfully.',
            icon: '/icons/icon-192x192.png',
            tag: 'sync-success'
          });
        }
      } catch (error) {
        console.error('Failed to sync complaint:', error);
      }
    }
  } catch (error) {
    console.error('Background sync failed:', error);
  }
}

// Handle push events (for future backend integration)
self.addEventListener('push', (event) => {
  if (event.data) {
    const data = event.data.json();
    
    const options = {
      body: data.body,
      icon: '/icons/icon-192x192.png',
      badge: '/icons/icon-96x96.png',
      tag: data.tag || 'push-notification',
      data: data.data || {},
      actions: data.actions || []
    };
    
    event.waitUntil(
      self.registration.showNotification(data.title, options)
    );
  }
});

// Periodic background fetch (alternative to push notifications)
self.addEventListener('periodicsync', (event) => {
  if (event.tag === 'complaint-updates') {
    event.waitUntil(checkForComplaintUpdates());
  }
});

async function checkForComplaintUpdates() {
  try {
    const response = await fetch('http://localhost:3000/complaints');
    const complaints = await response.json();
    
    // Get user's complaints (assuming user ID is stored)
    const userId = localStorage.getItem('userId');
    if (!userId) return;
    
    const userComplaints = complaints.filter(c => c.userId === userId);
    const lastCheck = localStorage.getItem('lastBackgroundCheck');
    
    if (lastCheck) {
      const updatedComplaints = userComplaints.filter(complaint => {
        const updatedAt = new Date(complaint.updatedAt || complaint.createdAt).getTime();
        return updatedAt > parseInt(lastCheck);
      });
      
      // Show notifications for updated complaints
      for (const complaint of updatedComplaints) {
        if (complaint.status !== 'pending') {
          await self.registration.showNotification(`Complaint #${complaint.id} Updated`, {
            body: `Status changed to: ${complaint.status}`,
            icon: '/icons/icon-192x192.png',
            tag: `complaint-${complaint.id}`,
            data: {
              type: 'complaint-update',
              complaintId: complaint.id,
              url: `/dashboard?complaint=${complaint.id}`
            }
          });
        }
      }
    }
    
    localStorage.setItem('lastBackgroundCheck', Date.now().toString());
  } catch (error) {
    console.error('Background complaint check failed:', error);
  }
}
